if ( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.8 )
	message ( FATAL_ERROR " CMAKE MINIMUM BACKWARD COMPATIBILITY REQUIRED : 2.8 !" )
endif( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.8 )

# Enforcing one time include https://cmake.org/Wiki/CMake_Performance_Tips#Use_an_include_guard
if(catkin_pip_setup_included)
  return()
endif(catkin_pip_setup_included)
set(catkin_pip_setup_included true)

message(STATUS "Loading catkin-pip-package.cmake from ${CMAKE_CURRENT_LIST_DIR}... ")


# protecting against missing cmake file
include ( "${CMAKE_CURRENT_LIST_DIR}/catkin-pip-runcmd.cmake" RESULT_VARIABLE CATKIN_PIP_RUNCMD_FOUND )
IF ( NOT CATKIN_PIP_RUNCMD_FOUND )
    message ( FATAL_ERROR "{CMAKE_CURRENT_LIST_DIR}/catkin-pip-runcmd.cmake Not Found !!!" )
ENDIF ( NOT CATKIN_PIP_RUNCMD_FOUND )

# protecting against missing cmake file
include ( "${CMAKE_CURRENT_LIST_DIR}/catkin-pip-prefix.cmake" RESULT_VARIABLE CATKIN_PIP_PREFIX_FOUND )
IF ( NOT CATKIN_PIP_PREFIX_FOUND )
    message ( FATAL_ERROR "{CMAKE_CURRENT_LIST_DIR}/catkin-pip-prefix.cmake Not Found !!!" )
ENDIF ( NOT CATKIN_PIP_PREFIX_FOUND )


# These are set on include time by catkin-pip and point to catkin-pip folders
if ( NOT CATKIN_PIP_TEMPLATES_PATH )
    # templates should found relative to our current path
    set (CATKIN_PIP_TEMPLATES_PATH ${CMAKE_CURRENT_LIST_DIR}/templates CACHE PATH "templates path")
endif()

# We are replacing catkin's python_setup functionality
# This is run by the package and CMAKE_CURRENT_LIST_DIR refer to the package one.
function(catkin_pip_python_setup)

    # Setting up variables for scripts configuration (in a function to keep it here)
    set(CATKIN_PIP_PACKAGE_PATH ${package_path})

    # sourcing envhooks to keep coherence between cmake run and shell run (especially for tests)
    # DUPLICATED with catkin_pip_setup
    #catkin_pip_runcmd(${CATKIN_PIP} install -e ${package_path} --no-dependencies --prefix "${CATKIN_DEVEL_PREFIX}")

    # BEGIN : This is from catkin_python_setup
    # we follow same process but with slightly different scripts
    #

      assert(PYTHON_INSTALL_DIR)
      assert(CATKIN_PIP_PYTHON_INSTALL_DIR)
      set(INSTALL_CMD_WORKING_DIRECTORY ${package_path})

      if(NOT WIN32)
        set(INSTALL_SCRIPT
          ${CMAKE_CURRENT_BINARY_DIR}/catkin_generated/python_setuptools_install.sh)
        configure_file(${CATKIN_PIP_TEMPLATES_PATH}/python_setuptools_install.sh.in
          ${INSTALL_SCRIPT}
          @ONLY)
      else()
        # need to convert install prefix to native path for python setuptools --prefix (its fussy about \'s)
        file(TO_NATIVE_PATH ${CMAKE_INSTALL_PREFIX} PYTHON_INSTALL_PREFIX)
        set(INSTALL_SCRIPT
          ${CMAKE_CURRENT_BINARY_DIR}/catkin_generated/python_setuptools_install.bat)
        configure_file(${CATKIN_PIP_TEMPLATES_PATH}/python_setuptools_install.bat.in
          ${INSTALL_SCRIPT}
          @ONLY)
      endif()

      # generate python script which gets executed at install time
      configure_file(${catkin_EXTRAS_DIR}/templates/safe_execute_install.cmake.in
        ${CMAKE_CURRENT_BINARY_DIR}/catkin_generated/safe_execute_install.cmake)
      install(SCRIPT ${CMAKE_CURRENT_BINARY_DIR}/catkin_generated/safe_execute_install.cmake)

    # END : This is the end of catkin_python_setup copy
    # Ideally we shouldn't need any more tricks for building the install space
    #

endfunction()


function(catkin_pip_target package_name)

    set (extra_macro_args ${ARGN})

    # Did we get any optional args?
    list(LENGTH extra_macro_args num_extra_args)
    if (${num_extra_args} GREATER 0)
        list(GET extra_macro_args 0 package_path)
        #message ("Got package_path: ${package_path}")
    else()
        set(package_path ${CMAKE_CURRENT_SOURCE_DIR})
    endif()

    set(${PROJECT_NAME}_PIP_TARGET ${package_name} CACHE STRING "Make target generated to install this pip package as --editable for development")

    # Note : environment should already be setup at configure time for devel

    # Then we can run the pip command
    # Note when installing in editable mode (for development) we shouldnt care about already installed versions.
    # However : https://github.com/asmodehn/catkin_pip/issues/58
    if(CATKIN_PIP_NO_DEPS)
        catkin_pip_install_devel_target(${package_name} ${package_path} --no-dependencies --ignore-installed)
        #catkin_pip_runcmd(${CATKIN_PIP} install -e ${package_path} --no-dependencies --prefix "${CATKIN_DEVEL_PREFIX}" --ignore-installed)
    else()
        catkin_pip_install_devel_target(${package_name} ${package_path} --ignore-installed)
        #catkin_pip_runcmd(${CATKIN_PIP} install -e ${package_path} --prefix "${CATKIN_DEVEL_PREFIX}" --ignore-installed)
    endif()

    if(NOT EXISTS ${package_path}/setup.py)
        message(FATAL_ERROR "catkin_pip_setup() called without 'setup.py' in project folder '${package_path}'")
    endif()

    # Probably better to do that here (dont do anything "special" for python)
    catkin_pip_python_setup()

    # TODO : we might want to generate a package.xml on the fly from setup.py contents...

endfunction()


# BWCOMPAT : eventually get rid of that...
macro(catkin_pip_package package_name)

    catkin_pip_target(${package_name} ${ARGN})

    # Here we plug back into usual catkin package build flow
    # CAREFUL : this will set variables into current scope.
    catkin_package()

endmacro()
